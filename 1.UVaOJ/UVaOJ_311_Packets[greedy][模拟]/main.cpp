#include <stdio.h>
#include <string.h>

/*
 * 1.因为所有盒子、箱子高度都是是相同的，所以实际就把问题转化为了6*6的正方形内放1*1,2*2,3*3...的格子的问题。
 * 2.要先放大的，再放小的。
 * 3.模拟放盒子的过程，其中放完大盒子后剩下的空间放尽量大的盒子(具体到这道题是2*2或1*1),
 *   比如说剩下的空间放尽量多的2*2，可以假设2*2一定是足够的，如果不够，最后把不够的2*2全部改放1*1.
 * 4.这道题我参考了这篇解题报告：http://www.cnblogs.com/staginner/archive/2011/09/23/2186187.html
 */

int a[9];
int main(){
    int i,packet,rest;
    while(true){
        //get input
        for(i=1; i<=6; i++)
            scanf("%d",&a[i]);
        if( !a[1] && !a[2] && !a[3] && !a[4] && !a[5] && !a[6] )
            break;

        //initial
        packet = 0;

        //size 6*6 ; 有多少个6*6就要用多少个箱子
        packet += a[6];

        //size 5*5 ; 一个箱子能放1个5*5 + 11个1*1
        packet += a[5];
        a[1] -= a[5] * 11;

        //size 4*4 ; 一个箱子最能放1个4*4 + 5个2*2
        packet += a[4];
        a[2] -= a[4] * 5;    //(1).先假设2*2是够的，如果不够，后边会把不够的部分替换成装1*1

        //size 3*3 ; 一个箱子能放4个3*3
        packet += a[3]/4;
        rest = a[3]%4;
        if( rest > 0 ){      //如果3*3有剩
            packet++;
            if( rest == 1 ){  
                a[2] -= 5;   //见(1)
                a[1] -= 7;   //剩下的空间放1*1
            }else if( rest == 2 ){
                a[2] -= 3;   //见(1)
                a[1] -= 6;   //剩下的空间放1*1
            }else if( rest == 3 ){  
                a[2] -= 1;   //见(1)
                a[1] -= 5;   //剩下的空间放1*1
            }
        }

        //size 2*2
        if( a[2] > 0 ){
            packet += a[2] / 9;
            rest = a[2] % 9;
            if( rest > 0 ){       //如果2*2有剩
                packet++;
                a[1] -= 36 - 4*rest;     //剩下的空间放1*1
            }
        }else if( a[2] < 0 ){    //如果2*2不够，就替换成1*1
            a[1] += a[2] * 4;
        }

        //size 1*1
        if( a[1] > 0 ){
            packet += a[1] / 36;
            if( a[1] % 36 > 0 )
                packet++;
        }

        printf("%d\n", packet);

    }
    
    return 0;
}

